# Тема проекту - “Аналіз зв’язності графів” 

У цьому проекті реалізована бібліотека, що може використовуватись для аналізу зв’язності графів.  

## Вона містить наступні можливості: 

#### 1) Читання файлу, у якому зберігається граф 

Функція працює як для орієнтованих, так і для неорієнтованих графів, повертаючи в залежності від цього різний результат. 

#### 2) Запис графу у файл  

Словник, що передається аргументом функції, записується у файл відповідно до вимог. 

#### 3) Пошук компонент зв’язності 

Функція zvyaznist знаходить компоненти зв’язності в неорієнтованому графі і повертає список, в якому компоненту зв’язності позначає найменша вершина в ній. 

Цей алгоритм базується на пошуку вшир в заданому графі. 

Для пошуку вшир функція бере першу вершину графа, та перевіряє, чи вона має ребра. Якщо так, то та сама операція продовжується для знайдених нових вершин. У противному випадку, вершина не має ребер, і функція рахує її як окрему компоненту зв’язності. 

Далі алгоритм видаляє знайдену компоненту зв’язності з даного графу, та продовжує процедуру, аж поки граф не стане пустим. 

Далі, по закінченню роботи алгоритму, функція відбирає найменші значення з кожної компоненти зв’язності. 

В функції був використаний вбудований модуль copy. 

#### 4) Пошук компонент сильної зв’язності 

#### 5) Пошук точок сполучення 

Основна функція -  articulation_points, що буде повертати необхідний результат (список із точок сполучення у графі). Вона використовує в собі функцію find_articulation_points, що працює на основі пошуку в глибину в графі. 

Детальніше про функцію find_articulation_points: 

Аргументами вона приймає словник, в якому записаний граф, та вершину з якої ми будемо починати пошук в глибину, тому що ми маємо пройтись по всіх компонентах зв’язності. За замовчуванням в стек поміщається введена аргументом вершина, та поки він не пустий ми проходимося по кожній вершині, та вершинах що з нею з’єднані, записуючи їх до множини предків/синів та поміщаючи у чергу і стек, допоки не досягнемо кінця (is_dead_end), очищаючи у такому випадку останній елемент зі стеку. Коли стек буде пустим - пошук в глибину буде завершено.  

Далі ми беремо елементи з черги, починаючи із першого індексу, оскільки для елемента з нульовим індексом маємо вже визначену на початку ситуацію, а також обертаємо цей список іншою стороною. 

Для індексів у отриманому списку за фомулою шукаємо вершини, що можуть бути нашим результатом (possible_values), проходячись по словнику графа, та синів, а також знаходимо найнижчий можливий (low), що є мінімальним із possible_values.  

Далі, проходячись по величинах, що є в діапазоні від 1 до (довжини словника графа + 1), ми перевіряємо, чи точка є точкою сполучення, чи ні та у першому випадку запсуємо її у список результатів. 

Ця функція повертає результат у формі списку та чергу. 

Детальніше про функцію articulation_points: 

Отримані дані з попередньої функції, проходять тут ще одну перевірку.  Ми проходимось по графу, перевіряючи чи елемента немає в множині використаних, якщо ні, то об’єднуємо множину used з множиною order (черги), а множину res з множиною result, отриманою з попередньої функції. 

Вкінці повертається список res - список точок сполучення, що і є результатом програми. 

#### 6) Пошук мостів 

Для пошуку мостів запустимо обхід в глибину з довільної вершини графа. 

Нехай ми знаходимося в обході в глибину, переглядаючи зараз всі ребра з вершини v. Тоді, якщo поточний ребро (v, to) таке, що з вершини to і з будь-якого її нащадка в дереві обходу в глибину не мають зворотної ребра в вершину v або будь-якого її предка, то це ребро є мостом. В іншому випадку воно мостом не є. 

Для перевірки цього факту для кожної вершини скористаємося "часом входу в вершину", що обчислюються алгоритмом пошуку в глибину. 

Отже, tin[v] - це час заходу пошуку в глибину в вершину v. Тепер введемо список low[v]. Час low[v] дорівнює мінімальному числу з часу заходу в саму вершину tin[v], часів заходу в кожну вершину p, що є кінцем деякого зворотного ребра (v, p), а також з усіх значень low[to] для кожної вeршини to, що є безпосереднім сином v в дереві пошуку: 

Тоді, з вершини v або її нащадка є зворотне ребро в її предка тоді і тільки тоді, коли знайдеться такий син to, що low [to] <= tin[v].  

Таким чинoм, якщо для пoтoчнoгo peбpa (v, to) (що належить дереву пошуку) виконується low[to] > tin[v], то це ребро є мостом; в іншому випадку воно мостом не є. 

Якщо знайшли міст - додаємо дане ребро до множини results, яка зберігає у собі усі ребра-мости. 

Функцією find_all_bridges ітеруємося по усіх компонентах зв’язності і, за допомогою функції find_bridges, перевіряючи вищезгадані умови, знаходимо мости у конкретній компоненті. 

 

## Розподіл роботи: 

Романус Ярослав - пошук компонент сильної зв’язності 

Гаврилів Анастасія - пошук точок сполучення 

Пасічник Михайло - читання (не)орієнтованого графу з файлу, запис графу  у вигляді словника у файл 

Муляк Аліна - пошук мостів 

Палка Олег - пошук компонент зв’язності 
